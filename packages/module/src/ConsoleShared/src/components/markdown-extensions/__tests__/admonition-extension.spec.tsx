  // Generated by Cursor
  // AI-assisted implementation with human review and modifications
import * as React from 'react';
import { render, screen } from '@testing-library/react';
import useAdmonitionShowdownExtension from '../admonition-extension';
import { marked } from 'marked';
// eslint-disable-next-line @typescript-eslint/no-require-imports
const DOMPurify = require('dompurify');

// Mock marked
jest.mock('marked', () => ({
  marked: {
    parseInline: jest.fn((text) => `<strong>${text}</strong>`),
  },
}));

// Mock DOMPurify
jest.mock('dompurify', () => ({
  sanitize: jest.fn((html) => html),
}));

// Test component that uses the hook
interface TestComponentProps {
  onExtensionReady?: (extension: any) => void;
}

const TestAdmonitionComponent: React.FunctionComponent<TestComponentProps> = ({ onExtensionReady }) => {
  const extension = useAdmonitionShowdownExtension();
  
  React.useEffect(() => {
    if (onExtensionReady) {
      onExtensionReady(extension);
    }
  }, [extension, onExtensionReady]);
  
  return (
    <div data-testid="test-component">
      <div data-testid="extension-type">{extension.type}</div>
      <div data-testid="extension-regex-source">{extension.regex.source}</div>
      <div data-testid="extension-regex-flags">{extension.regex.flags}</div>
      <button 
        data-testid="test-replace-button"
        onClick={() => {
          const result = extension.replace(
            '[Test message]{{admonition note}}',
            'Test message',
            'admonition',
            'note'
          );
          const resultDiv = document.createElement('div');
          resultDiv.innerHTML = result;
          resultDiv.setAttribute('data-testid', 'replace-result');
          document.body.appendChild(resultDiv);
        }}
      >
        Test Replace
      </button>
    </div>
  );
};

describe('useAdmonitionShowdownExtension', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Clean up any previous test results
    const existingResults = document.querySelectorAll('[data-testid="replace-result"]');
    existingResults.forEach(el => el.remove());
  });

  it('should return extension with correct type', () => {
    render(<TestAdmonitionComponent />);
    expect(screen.getByTestId('extension-type').textContent).toBe('lang');
  });

  it('should return extension with global regex', () => {
    render(<TestAdmonitionComponent />);
    expect(screen.getByTestId('extension-regex-flags').textContent).toBe('g');
  });

  it('should return extension with correct regex pattern for admonitions', () => {
    render(<TestAdmonitionComponent />);
    const regexSource = screen.getByTestId('extension-regex-source').textContent;
    expect(regexSource).toBe('\\[(.+)]{{(admonition) ([\\w-]+)}}');
  });

  describe('regex pattern matching', () => {
    let extension: any;

    beforeEach(() => {
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
    });

    it('should match NOTE admonition syntax', () => {
      const testText = '[Important message here]{{admonition note}}';
      const regex = new RegExp(extension.regex);
      const matches = regex.exec(testText);
      
      expect(matches).not.toBeNull();
      expect(matches![1]).toBe('Important message here');
      expect(matches![2]).toBe('admonition');
      expect(matches![3]).toBe('note');
    });

    it('should match different admonition types', () => {
      const admonitionTypes = ['note', 'tip', 'important', 'warning', 'caution'];
      
      admonitionTypes.forEach(type => {
        const testText = `[Content for ${type}]{{admonition ${type}}}`;
        const regex = new RegExp(extension.regex);
        const matches = regex.exec(testText);
        
        expect(matches).not.toBeNull();
        expect(matches![3]).toBe(type);
      });
    });

    it('should match admonitions with hyphenated types', () => {
      const testText = '[Content]{{admonition custom-type}}';
      const regex = new RegExp(extension.regex);
      const matches = regex.exec(testText);
      
      expect(matches).not.toBeNull();
      expect(matches![3]).toBe('custom-type');
    });

    it('should match multiple admonitions in the same text', () => {
      const testText = `
        [First note]{{admonition note}}
        Some other content
        [Warning message]{{admonition warning}}
      `;
      
      const matches = Array.from(testText.matchAll(extension.regex));
      expect(matches).toHaveLength(2);
      expect(matches[0][3]).toBe('note');
      expect(matches[1][3]).toBe('warning');
    });

    it('should not match malformed admonition syntax', () => {
      const malformedCases = [
        'Content]{{admonition note}}',
        '[Content{{admonition note}}',
        '[Content]{{admonition note}',
        '[Content]{{admonition}}',
        '[Content]{{notadmonition note}}',
        '[Content]{{admonition note extra}}',
      ];

      malformedCases.forEach(testCase => {
        const matches = testCase.match(extension.regex);
        expect(matches).toBeNull();
      });
    });
  });

  describe('HTML generation', () => {
    it('should generate correct alert HTML structure when replace function is called', () => {
      render(<TestAdmonitionComponent />);
      
      const testButton = screen.getByTestId('test-replace-button');
      testButton.click();
      
      const result = document.querySelector('[data-testid="replace-result"]');
      expect(result).not.toBeNull();
      
      // Check for PatternFly alert classes in HTML
      expect(result!.innerHTML).toContain('pf-v6-c-alert');
      expect(result!.innerHTML).toContain('pf-m-info'); // NOTE maps to info variant
      expect(result!.innerHTML).toContain('pf-m-inline');
      expect(result!.innerHTML).toContain('pfext-markdown-admonition');
      
      // Check title shows the admonition type (uppercase)
      expect(result!.textContent).toContain('NOTE');
    });

    it('should call marked.parseInline and DOMPurify.sanitize during rendering', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      // Call replace function directly
      extension.replace(
        '[**Bold text**]{{admonition note}}',
        '**Bold text**',
        'admonition',
        'note'
      );

      expect(marked.parseInline).toHaveBeenCalledWith('**Bold text**');
      expect(DOMPurify.sanitize).toHaveBeenCalled();
    });

    it('should handle different admonition types with correct variants', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      const testCases = [
        { type: 'note', expectedClass: 'pf-m-info' },
        { type: 'tip', expectedClass: 'pf-m-custom' },
        { type: 'important', expectedClass: 'pf-m-danger' },
        { type: 'warning', expectedClass: 'pf-m-warning' },
        { type: 'caution', expectedClass: 'pf-m-warning' },
      ];

      testCases.forEach(({ type, expectedClass }) => {
        const result = extension.replace(
          `[Content]{{admonition ${type}}}`,
          'Content',
          'admonition',
          type
        );

        expect(result).toContain(expectedClass);
        expect(result).toContain(type.toUpperCase());
      });
    });
  });

  describe('edge cases and validation', () => {
    it('should return original text when content is missing', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      const originalText = '[Content]{{admonition note}}';
      const result = extension.replace(originalText, '', 'admonition', 'note');
      
      expect(result).toBe(originalText);
    });

    it('should return original text when admonition type is missing', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      const originalText = '[Content]{{admonition}}';
      const result = extension.replace(originalText, 'Content', 'admonition', '');
      
      expect(result).toBe(originalText);
    });

    it('should return original text when command is not admonition', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      const originalText = '[Content]{{something note}}';
      const result = extension.replace(originalText, 'Content', 'something', 'note');
      
      expect(result).toBe(originalText);
    });

    it('should handle content with HTML entities', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      const result = extension.replace(
        '[Content with &lt;tags&gt; &amp; entities]{{admonition note}}',
        'Content with &lt;tags&gt; &amp; entities',
        'admonition',
        'note'
      );

      expect(result).toContain('Content with &lt;tags&gt; &amp; entities');
      expect(result).toContain('class="pf-v6-c-alert');
    });

    it('should convert admonition type to uppercase in title', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      const result = extension.replace(
        '[Content]{{admonition note}}',
        'Content',
        'admonition',
        'note'
      );

      expect(result).toContain('NOTE');
      expect(result).not.toMatch(/[^A-Z]note[^A-Z]/); // Should not contain lowercase 'note'
    });

    it('should handle very long content', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      const longContent = 'This is a very long message that might cause layout issues'.repeat(3);
      const result = extension.replace(
        `[${longContent}]{{admonition note}}`,
        longContent,
        'admonition',
        'note'
      );

      expect(result).toContain('class="pf-v6-c-alert');
      expect(result).toContain(longContent);
    });
  });

  describe('unknown admonition types', () => {
    it('should handle unknown admonition types gracefully', () => {
      let extension: any;
      const handleExtensionReady = (ext: any) => {
        extension = ext;
      };
      
      render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      expect(() => {
        extension.replace(
          '[Content]{{admonition unknown}}',
          'Content',
          'admonition',
          'unknown'
        );
      }).not.toThrow();
    });
  });

  describe('memoization', () => {
    it('should return the same extension object on subsequent renders', () => {
      let callCount = 0;
      let firstExtension: any;
      let secondExtension: any;
      
      const handleExtensionReady = (ext: any) => {
        callCount++;
        if (callCount === 1) {
          firstExtension = ext;
        } else if (callCount === 2) {
          secondExtension = ext;
        }
      };
      
      const { rerender } = render(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      rerender(<TestAdmonitionComponent onExtensionReady={handleExtensionReady} />);
      
      expect(callCount).toBeGreaterThanOrEqual(1);
      expect(firstExtension).toBeDefined();
      expect(firstExtension.type).toBe('lang');
      expect(typeof firstExtension.replace).toBe('function');
    });
  });
}); 